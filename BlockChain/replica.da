import collections
import sys
from nacl.signing import SigningKey
from collections import defaultdict

from BlockTree import BlockTree
from LeaderElection import LeaderElection
from Safety import Safety
from Ledger import Ledger

from QC import QC
from TC import TC

from TimeoutMsg import TimeoutMsg
from ProposalMsg import ProposalMsg

LOCAL_TIMEOUT = "local_timeout"
PROPOSAL_MESSAGE = "proposal_message"
VOTE_MESSAGE = "vote_message"
TIMEOUT_MESSAGE = "timeout_message"
CLIENT_MESSAGE = "client_message"
CLIENT_FIN_MESSAGE = "client_fin_message"

class Replica(process):

################################################################################
                        #   Pace Maker module
################################################################################

    # set based on the config
    def PaceMaker_get_round_timer(r = None):
        delta = 1              # Todo - fetch from config
        return 4 * delta
    
    # Not required
    def PaceMaker_start_timer(new_round):
        self.round_done = True  # stop_timer(self.current_round)
        self.current_round = new_round
        
    # Function to be triggered on Timeout
    def PaceMaker_local_timeout_round():
        timeout_info = self.safety.make_timeout(self.current_round, self.block_tree.high_qc, self.last_round_tc)
        tmoMsg = TimeoutMsg(timeout_info, self.last_round_tc, self.block_tree.high_commit_qc)
        send((TIMEOUT_MESSAGE, tmoMsg), to = replicas)

    def PaceMaker_process_remote_timeout(tmo):
        tmo_info = tmo.tmo_info
        if tmo_info.round < self.current_round:
            return None

        lst_sender = [tmo_v.sender for tmo_v in self.pending_timeouts[tmo_info.round]]

        if tmo_info.sender not in lst_sender:
            self.pending_timeouts[tmo_info.round].append(tmo_info)
            lst_sender.append(tmo_info.sender)

        # Todo - read f from config
        f = 1
        if len(lst_sender) == f+1:
            # stop_timer(self.current_round)
            self.round_done = True # Todo - Not sure if we shld stop timer
            self.PaceMaker_local_timeout_round()

        lst_high_qc_round = [tmo_v.high_qc for tmo_v in self.pending_timeouts[tmo_info.round]]
        lst_signature     = [tmo_v.signature for tmo_v in self.pending_timeouts[tmo_info.round]]

        if len(lst_sender) == 2*f+1:
            return TC(tmo_info.round, lst_high_qc_round, lst_signature)
            
        return None

    def PaceMaker_advance_round_tc(tc):
        if tc == None or tc.round < self.current_round:
            return False
        self.last_round_tc = tc
        self.start_timer(tc.round + 1)
        return True

    def PaceMaker_advance_round_qc(qc):
        if qc is None or qc.vote_info.round < self.current_round:
            return False
        self.last_round_tc = None
        self.PaceMaker_start_timer(qc.vote_info.round + 1)
        return True

################################################################################
                        #   MAIN MODULE
################################################################################

    def process_certificate_qc(qc : QC):
        self.block_tree.process_qc(qc, self.mempool)
        # self.leader_election.update_leaders(qc)
        self.PaceMaker_advance_round_qc(qc)

    def process_proposal_msg(P : ProposalMsg):
        self.process_certificate_qc(P.block.qc)
        self.process_certificate_qc(P.high_commit_qc)
        self.PaceMaker_advance_round_tc(P.last_round_tc)
        round = self.current_round
        # leader = self.leader_election.get_leader(round)
        leader = 0
        
        # P.block.round != round V P.sender != leader âˆ¨ P.block.author != leader
        # What is P.Sender ?, is it just P.block.author?
        if (P.block.round != round or P.block.author != leader):
            return

        self.block_tree.execute_and_insert(P.block)
        vote_msg = self.safety.make_vote(P.block, P.last_round_tc, 0)
        if (vote_msg != None):
            # output("i am replica", self.replica_id, "i am sending vote messages to ", self.replicas[0], " for id", vote_msg.vote_info.id)
            send((VOTE_MESSAGE, vote_msg), to = self.replicas[0])

    def process_timeout_msg(M : TimeoutMsg):
        self.PaceMaker_advance_round_tc(tc)
        self.process_new_round_event(tc)
        self.process_certificate_qc(M.tmo_info.high_qc)
        self.process_certificate_qc(M.high_commit_qc)
        self.PaceMaker_advance_round_tc(M.last_round_tc)
        tc = self.PaceMaker_process_remote_timeout(M)
        if tc != None:
            self.PaceMaker_advance_round_tc(tc)
            self.process_new_round_event(tc)

    def process_vote_msg(M: VoteMsg):
        qc = self.block_tree.process_vote(M, 0, self.signing_key, self.mempool)
        if qc != None:
            self.process_certificate_qc(qc)
            self.process_new_round_event(None)
        
    def process_new_round_event(last_tc: TC):
        # output("entering new round for ", self.replica_id, "mempool", self.mempool)
        u = 0
        if u != None and len(self.mempool) > 0:
            b = self.block_tree.generate_block(u, self.current_round, self.mempool.popleft(), "id" + str(self.current_round))
            proposal_msg_p = ProposalMsg(b, last_tc, self.block_tree.high_commit_qc, self.sign_message(b.id, self.signing_key))
            send((PROPOSAL_MESSAGE, proposal_msg_p), to = self.replicas.values())

################################################################################
                        #   Setup and run
################################################################################

    def setup(replica_id, replicas, verify_key, signing_key, verify_key_list_replica, verify_key_list_client):

        # ====== attributes for process end of replica ======
        self.run_done = False

        # ====== attributes for pace maker ======
        self.current_round = 1
        self.last_round_tc = None
        self.pending_timeouts = defaultdict(list)
        # =======================================

        self.first_leader = 0

        # ====== attributes for Mempool ======
        self.mempool = collections.deque()
        # =======================================

        # # def __init__(self, pending_votes, high_qc, high_commit_qc, pending_block_tree):
        # # Update with proper values
        # # Create Genesis block and set pending_block_tree = Genesis block
        self.ledger = Ledger(self.replica_id)
        self.block_tree = BlockTree(self.ledger, verify_key_list_replica)

        # #def __init__(self, validators, window_size, exclude_size, reputation_leaders):
        # #Update with proper values
        # self.leader_election = LeaderElection(replicas, 0, 0, replicas)

        # self.ledger = Ledger(str(self.replica_id))
        # self.block_tree = BlockTree(self.ledger)

        # #def __init__(self, private_key, public_keys):
        # #We already have private_key(signing key) & public_keys(verify keys)
        self.safety = Safety(self.signing_key, verify_key_list_replica, self.ledger, self.block_tree)

    def run():
        output("Replica Spawned, id = ", self.replica_id)
        # await(self.tot_msg == 0)
        # while not self.run_done:
        #     self.round_done = False
        #     timer_duration = self.PaceMaker_get_round_timer()
        #     if await(self.round_done == True) : 
        #         pass
        #     elif timeout(timer_duration):
        #         print("Timeout Triggered")
        #         self.PaceMaker_local_timeout_round()

        if(self.current_round == 1 and self.replica_id == 0):
            first_round_leader = 0
            #Get from the mempool and send a proposal message
            await(len(self.mempool) > 0)
            self.process_new_round_event(None)

        await(False)

################################################################################
                        #   Handler for messages
################################################################################

    #Handler for messages from other Replicas
    def receive(msg=(message_type, message_object), from_ = sender):
        if message_type == CLIENT_FIN_MESSAGE:
            self.run_done = True
            return

        elif message_type == CLIENT_MESSAGE:
            client_id = message_object.id
            client_verify_key = verify_key_list_client[client_id]
            client_msg = verify_and_get_signed_message(message_object.signed_message, client_verify_key)
            # output("Client", client_id,  "Sent me this message : ", client_msg)
            self.mempool.append(client_msg)
            
        elif message_type == PROPOSAL_MESSAGE:
            self.process_proposal_msg(message_object)

        elif message_type == VOTE_MESSAGE:
            # output("i am replica", self.replica_id, " i am receiving vote messages")
            self.process_vote_msg(message_object)

        elif message_type == TIMEOUT_MESSAGE:
            self.process_timeout_msg(message_object)

        else:
            output("Message Type Not Recognized")
        

################################################################################
                        #   Helpers
################################################################################

    #Sign a message str using a signing key
    def sign_message(message : str, signing_key : nacl.signing.SigningKey):
        #Encode the message
        message = message.encode('ascii')
        #Sign the message and return the signed message
        return signing_key.sign(message)

    #Verifies the signed message and returns the message
    def verify_and_get_signed_message(signed_message : str, verify_key : nacl.signing.VerifyKey):
        verify_key.verify(signed_message)
        return signed_message.message.decode('ascii')