import sys
from nacl.signing import SigningKey

from BlockTree import BlockTree
from LeaderElection import LeaderElection
from Pacemaker import Pacemaker
from Safety import Safety

from QC import QC

from TimeoutMsg import TimeoutMsg
from ProposalMsg import ProposalMsg

LOCAL_TIMEOUT = "local_timeout"
PROPOSAL_MESSAGE = "proposal_message"
VOTE_MESSAGE = "vote_message"
TIMEOUT_MESSAGE = "timeout_message"
CLIENT_MESSAGE = "client_message"
CLIENT_FIN_MESSAGE = "client_fin_message"

class Replica(process):
    def setup(replica_id, replicas, verify_key, signing_key, verify_key_list_replica, verify_key_list_client):
        self.run_done = False

        # def __init__(self, pending_votes, high_qc, high_commit_qc, pending_block_tree):
        # Update with proper values
        # Create Genesis block and set pending_block_tree = Genesis block
        self.block_tree = BlockTree(10, 10, 10, None)

        #def __init__(self, validators, window_size, exclude_size, reputation_leaders):
        #Update with proper values
        self.leader_election = LeaderElection(replicas, 0, 0, replicas)

        self.pace_maker = Pacemaker()

        #def __init__(self, private_key, public_keys):
        #We already have private_key(signing key) & public_keys(verify keys)
        self.safety = Safety(self.signing_key, verify_key_list_replica)

    def run():
        output("Replica Spawned, id = ", self.replica_id)
        # await(self.tot_msg == 0)
        await(self.run_done == True) # Also await on process finishing

    ################################################################################
    #   MAIN MODULE
    ################################################################################

    def process_certificate_qc(self, qc : QC):
        self.block_tree.process_qc(qc)
        self.leader_election.update_leaders(qc)
        self.pace_maker.advance_round_qc(qc.vote_info.round)

    def process_proposal_msg(self, P : ProposalMsg):
        self.process_certificate_qc(P.block.qc)
        self.process_certificate_qc(P.high_commit_qc)
        self.pace_maker.advance_round_tc(P.last_round_tc)
        round = self.pace_maker.current_round
        leader = self.leader_election.get_leader(round)

        # P.block.round != round V P.sender != leader âˆ¨ P.block.author != leader
        #What is P.Sender ?, is it just P.block.author?
        if (P.block.round != round or P.block.author != leader):
            return

        self.block_tree.execute_and_insert(P)
        vote_msg = self.safety.make_vote(P.block, P.last_round_tc)
        if (vote_msg != None):
            #send vote msg to LeaderElection.get leader(current round+ 1)
            pass

    def process_timeout_msg(self, M : TimeoutMsg):
        self.process_certificate_qc(M.tmo_info.high_qc)
        self.process_certificate_qc(M.high_commit_qc)
        self.pace_maker.advance_round_tc(M.last_round_tc)
        tc = self.pace_maker.process_remote_timeout(M)
        if tc != None:
            self.pace_maker.advance_round_tc(tc)
            self.process_new_round_event(tc)

    def process_vote_msg(self, M: VoteMsg):
        qc = self.block_tree.process_vote(M)
        if qc != None:
            self.process_certificate_qc(qc)
            self.process_new_round_event(None)

    #Sign a message str using a signing key
    def sign_message(message : str, signing_key : nacl.signing.SigningKey):
        #Encode the message
        message = message.encode('ascii')
        #Sign the message and return the signed message
        return signing_key.sign(message)

    def send_proposal_msg(self, msg : str):
        signed_msg_to_send = self.sign_message(msg, self.signing_key)
        send((PROPOSAL_MESSAGE, signed_msg_to_send), to = self.replicas)

    def process_new_round_event(self, last_tc: TC):
        u = LeaderElection.get_leader(self.pace_maker.current_round)
        if u != None:
            b = self.block_tree.generate_block(MemPool.get_transactions(), self.pace_maker.current_round)
            proposal_msg_p = ProposalMsg(b, last_tc, self.block_tree.high_commit_qc)
            self.send_proposal_msg(proposal_msg_p)

    # Todo - local timeout is never recieved from other process - Remove Below code
    #Handler for local timeout
    def receive(msg=(LOCAL_TIMEOUT, local_timeout_message), from_ = replica):
        process_timeout_msg(local_timeout_message)
        pass

    def receive(msg=(PROPOSAL_MESSAGE, proposal_message), from_ = replica):
        process_proposal_msg(proposal_message)
        pass

    def receive(msg=(VOTE_MESSAGE, vote_msg), from_ = replica):
        process_vote_msg(vote_msg)
        pass

    def receive(msg=(TIMEOUT_MESSAGE, local_timeout_message), from_ = replica):
        process_timeout_msg(local_timeout_message)
        pass

    #Handler for client message
    def receive(msg=(msg_type, client_message), from_ = client):
        if(msg_type == CLIENT_FIN_MESSAGE):
            self.run_done = True
            return
        
        #Else - Message type = CLIENT_MESSAGE // request
        # Todo - Add to Mempool
        client_id = client_message.id
        client_verify_key = verify_key_list_client[client_id]
        client_msg = verify_and_get_signed_message(client_message.signed_message, client_verify_key)
        output("Client", client_id,  "Sent me this message : ", client_msg)

    #Verifies the signed message and returns the message
    def verify_and_get_signed_message(signed_message : str, verify_key : nacl.signing.VerifyKey):
        verify_key.verify(signed_message)
        return signed_message.message.decode('ascii')