import collections
from random import random
import sys
import time
from nacl.signing import SigningKey
from collections import defaultdict
from enum import Enum
from collections import namedtuple

from BlockTree import BlockTree
from LeaderElection import LeaderElection
from Safety import Safety
from Ledger import Ledger
from Mempool import Mempool

from QC import QC
from TC import TC

from TimeoutMsg import TimeoutMsg
from ProposalMsg import ProposalMsg

import pickle
import logging
import logging.config

from config import *

# PROPOSAL_MESSAGE = "proposal_message"
# VOTE_MESSAGE = "vote_message"
# TIMEOUT_MESSAGE = "timeout_message"
CLIENT_MESSAGE = "client_message"
CLIENT_FIN_MESSAGE = "client_fin_message"

# class MsgType(Enum):
#     Proposal = 1
#     QC = 2
#     TimeOut = 3
#     Vote = 4
#     Wildcard = 5

# class FailType(Enum):
#     MsgLoss = 1
#     Delay = 2
#     SetAttr = 3
# ------------------------------------------------------

class Replica(process):

    def setup(replica_id, replicas, verify_key, signing_key, verify_key_list_replica, verify_key_list_client):
        self.run_done = False
        self.last_round_tc = None
        self.pending_timeouts = defaultdict(list)
        # self.mempool = collections.deque()
        self.mem_pool = Mempool()
        self.ledger = Ledger(self.replica_id, self.mem_pool)
        self.block_tree = BlockTree(self.ledger, self.replica_id, self.verify_key_list_replica)
        self.leader_election = LeaderElection(replicas, 3, 3, replicas, self.ledger, self.block_tree)
        self.safety = Safety(self.signing_key, verify_key_list_replica, self.ledger, self.block_tree)
        # self.log = self.Logger(file_name)

    def run():
        output("Replica Spawned, id = ", self.replica_id)
        # while not self.run_done or len(self.mempool) > 0:
        while not self.run_done or self.mem_pool.exists():
            self.round_done = False
            timer_duration = self.PaceMaker_get_round_timer()
            if await(self.round_done == True) : 
                pass
            elif timeout(timer_duration):
                self.PaceMaker_local_timeout_round()


    def setattr(attr,val):
        if attr == "current_round":
            self.block_tree.current_round = val
        elif attr == "highest_vote_round":
            self.safety.set_highest_vote_round(val)
        

    def process_certificate_qc(qc : QC):
        self.block_tree.process_qc(qc)
        self.leader_election.update_leaders(qc)
        self.PaceMaker_advance_round_qc(qc)

        
    def process_proposal_msg(P : ProposalMsg):
        self.process_certificate_qc(P.block.qc)
        self.process_certificate_qc(P.high_commit_qc)
        self.PaceMaker_advance_round_tc(P.last_round_tc)
        round = self.block_tree.current_round
        leader = self.leader_election.get_leader(round)

        # if P.block.payload in self.mempool:
        #     self.mempool.remove(P.block.payload)

        print("Received Transaction Id = ", P.block.txn_id)
        self.mem_pool.processTransaction(P.block.txn_id)

        # P.block.round != round V P.sender != leader âˆ¨ P.block.author != leader
        #What is P.Sender ?, is it just P.block.author?
        # print("hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh")
        # if (P.block.round == round and P.block.author == leader):
        #     return
        

        self.block_tree.execute_and_insert(P.block)
        vote_msg = self.safety.make_vote(P.block, P.last_round_tc)
        vote_msg = pickle.dumps(vote_msg)
        # print("Send Vote Message")
        # print(vote_msg)
        if (vote_msg != None):
            #send vote msg to LeaderElection.get leader(current round+ 1)
            next_leader = self.leader_election.get_leader(self.block_tree.current_round+1)
            self.round_done = True
            send((MsgType.Vote, vote_msg), to = self.replicas[next_leader])   # Fix - Need to send to only Next leader
            # print(replica_id, " Sent Vote Message*********************************")
            pass

    def process_timeout_msg(M : TimeoutMsg):
        self.process_certificate_qc(M.tmo_info.high_qc)
        self.process_certificate_qc(M.high_commit_qc)
        self.PaceMaker_advance_round_tc(M.last_round_tc)
        tc = self.PaceMaker_process_remote_timeout(M)
        if tc != None:
            self.PaceMaker_advance_round_tc(tc)
            self.process_new_round_event(tc)

    def process_vote_msg(M: VoteMsg):
        M = pickle.loads(M)
        qc = self.block_tree.process_vote(M)
        if qc != None:
            self.process_certificate_qc(qc)
            self.process_new_round_event(None)

    #Sign a message str using a signing key
    def sign_message(message : str, signing_key : nacl.signing.SigningKey):
        #Encode the message
        message = message.encode('ascii')
        #Sign the message and return the signed message
        return signing_key.sign(message)

    # def send_proposal_msg(msg : str):
    #     signed_msg_to_send = self.sign_message(msg, self.signing_key)
    #     send((PROPOSAL_MESSAGE, signed_msg_to_send), to = self.replicas.values())

    def process_new_round_event(last_tc: TC):
        u = self.leader_election.get_leader(self.block_tree.current_round)
        if u != None and u == replica_id:
            # pass
            # if self.mempool:
            if self.mem_pool.exists():
                # b = self.block_tree.generate_block(self.mempool.popleft(), self.block_tree.current_round)
                (txn_id, txn) = self.mem_pool.getTransactions()
                b = self.block_tree.generate_block(txn, self.block_tree.current_round, txn_id)
                proposal_msg_p = ProposalMsg(b, last_tc, self.block_tree.high_commit_qc, verify_key_list_replica[replica_id])
                send((MsgType.Proposal, proposal_msg_p), to = replicas.values())


    #Handler for messages from other Replicas
    def receive(msg=(message_type, message_object), from_ = replica):
        
        if message_type == MsgType.Proposal:
            print(replica_id, "Received Proposal Message ***********************")
            self.process_proposal_msg(message_object)

        elif message_type == MsgType.Vote:
            print(replica_id, "Received Vote Message *****************************")
            self.process_vote_msg(message_object)

        elif message_type == MsgType.TimeOut:
            print(replica_id, "Received Timeout Message *************************")
            self.process_timeout_msg(message_object)

    #Handler for client message
    def receive(msg=(msg_type, client_message), from_ = clients):
        if(msg_type == CLIENT_FIN_MESSAGE):
            self.run_done = True
            return
        elif msg_type == CLIENT_MESSAGE:
            client_id = client_message.id
            txn_id = client_message.txn_id
            client_verify_key = verify_key_list_client[client_id]
            client_msg = verify_and_get_signed_message(client_message.signed_message, client_verify_key)
            # self.mempool.append(client_msg)
            self.mem_pool.addTransaction(txn_id, client_msg)

    #Verifies the signed message and returns the message
    def verify_and_get_signed_message(signed_message : str, verify_key : nacl.signing.VerifyKey):
        verify_key.verify(signed_message)
        return signed_message.message.decode('ascii')



    # set based on the config
    def PaceMaker_get_round_timer(r = None):
        delta = 1              # Todo - fetch from config
        return 4 * delta
    
    # Not required
    def PaceMaker_start_timer(new_round):
        self.round_done = True  # stop_timer(self.current_round)
        self.block_tree.current_round = new_round
        
    # Function to be triggered on Timeout
    def PaceMaker_local_timeout_round():
        timeout_info = self.safety.make_timeout(self.block_tree.current_round, self.block_tree.high_qc, self.last_round_tc)
        if(self.block_tree.current_round == 0):
            #Send TC Anyway
            pass
        tmoMsg = TimeoutMsg(timeout_info, self.last_round_tc, self.block_tree.high_commit_qc)
        send((MsgType.TimeOut, tmoMsg), to = replicas.values())

    

    # TimeoutMsg Handler======================================================================
    def PaceMaker_process_remote_timeout(tmo):
        
        tmo_info = tmo.tmo_info
        if tmo_info.round < self.block_tree.current_round:
            print("tmo_info.round = ", tmo_info.round, "  self.block_tree.current_round ", self.block_tree.current_round)
            return None

        lst_sender = [tmo_v.sender for tmo_v in self.pending_timeouts[tmo_info.round]]

        if tmo_info.sender not in lst_sender:
            self.pending_timeouts[tmo_info.round].append(tmo_info)
            lst_sender.append(tmo_info.sender)

        if len(lst_sender) == f+1:
            # stop_timer(self.current_round)
            self.round_done = True # Todo - Not sure if we shld stop timer
            print("Nooooooooooooooooooooooooooooooooooooooooooo")
            self.PaceMaker_local_timeout_round()

        print(lst_sender)

        lst_high_qc_round = [tmo_v.high_qc for tmo_v in self.pending_timeouts[tmo_info.round]]
        lst_signature     = [tmo_v.signature for tmo_v in self.pending_timeouts[tmo_info.round]]

        if len(lst_sender) == 2*f+1:
            print("2f +1 for TC")
            return TC(tmo_info.round, lst_high_qc_round, lst_signature)

        print("Returning None ---------------------")

        return None
    # =============================================================================================



    def PaceMaker_advance_round_tc(tc):
        if tc == None or tc.round < self.block_tree.current_round:
            return False
        self.last_round_tc = tc
        self.PaceMaker_start_timer(tc.round + 1)
        return True

    def PaceMaker_advance_round_qc(qc):
        if qc.vote_info.round < self.block_tree.current_round:
            return False
        self.last_round_tc = None
        self.PaceMaker_start_timer(qc.vote_info.round + 1)
        return True


    def Logger(file_name):
        logging.basicConfig(filename=file_name,
                            filemode='a',
                            format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',
                            datefmt='%H:%M:%S',
                            level=logging.DEBUG)

        log_obj = logging.getLogger()
        log_obj.setLevel(logging.DEBUG)

        log_obj.info("Logger object created successfully..")
        return log_obj

# ----------------------------------------- End of Replica Class -------------------------------


class ReplicaFI(process, Replica):
    def send(m, to):
        dont_send = False
        i = 0.6
        for fail_case in failure_config.failures:
            if ( fail_case.src == self.replica_id or fail_case.src == '_') and ( fail_case.msg_type == m[0] or fail_case.msg_type ==  MsgType.Wildcard ) and fail_case.round == self.block_tree.current_round and i >= fail_case.prob:
                if fail_case.dest not in to:
                    continue
                if fail_case.fail_type == FailType.MsgLoss:
                    dont_send = True
                if fail_case.fail_type == FailType.Delay:
                    time.sleep(4)
                if fail_case.fail_type == FailType.SetAttr:
                    setattr(fail_case.attr, fail_case.val)
        if not dont_send:
            super().send(m,to)