import sys
from nacl.signing import SigningKey
from nacl.signing import SignedMessage

from BlockTree import BlockTree
from LeaderElection import LeaderElection
from Pacemaker import Pacemaker
from Safety import Safety

from QC import QC

from TimeoutMsg import TimeoutMsg
from ProposalMsg import ProposalMsg

LOCAL_TIMEOUT = "local_timeout"
PROPOSAL_MESSAGE = "proposal_message"
VOTE_MESSAGE = "vote_message"
TIMEOUT_MESSAGE = "timeout message"
CLIENT_MESSAGE = "client_message"

class ClientRequestMessage:
    id : int
    signed_message : nacl.signing.SignedMessage

    def __init__(self, id, signed_message):
        self.id = id
        self.signed_message = signed_message

class Client(process):
    def setup(client_id, replicas, verify_key, signing_key, verify_key_list_replica):
        pass

    def send_client_req_msg(msg : str):
        signed_msg_to_send = sign_message(msg, self.signing_key)
        client_request_message = ClientRequestMessage(self.client_id, signed_msg_to_send)
        send((CLIENT_MESSAGE, client_request_message), to = replicas)

    def run():
        output("Client Spawned, id = ", self.client_id)
        send_client_req_msg("test")

class Replica(process):
    def setup(replica_id, replicas, verify_key, signing_key, verify_key_list_replica, verify_key_list_client):
        self.tot_msg = 3

        # def __init__(self, pending_votes, high_qc, high_commit_qc, pending_block_tree):
        # Update with proper values
        # Create Genesis block and set pending_block_tree = Genesis block
        self.block_tree = BlockTree(10, 10, 10, None)

        #def __init__(self, validators, window_size, exclude_size, reputation_leaders):
        #Update with proper values
        self.leader_election = LeaderElection(replicas, 0, 0, replicas)

        self.pace_maker = Pacemaker()

        #def __init__(self, private_key, public_keys):
        #We already have private_key(signing key) & public_keys(verify keys)
        self.safety = Safety(self.signing_key, verify_key_list_replica)

    def run():
        output("Replica Spawned, id = ", self.replica_id)
        await(tot_msg == 0)

################################################################################
            #   MAIN MODULE
################################################################################

    def process_certificate_qc(qc : QC):
        self.block_tree.process_qc(qc)
        self.leader_election.update_leaders(qc)
        self.pace_maker.advance_round_qc(qc.vote_info.round)

    def process_proposal_msg(P : ProposalMsg):
        process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)
        self.pace_maker.advance_round_tc(P.last_round_tc)
        round = self.pace_maker.current_round
        leader = self.leader_election.get_leader(round)

        # P.block.round != round V P.sender != leader âˆ¨ P.block.author != leader
        #What is P.Sender ?, is it just P.block.author?
        if (P.block.round != round or P.block.author != leader):
            return

        self.block_tree.execute_and_insert(P)
        vote_msg = self.safety.make_vote(P.block, P.last_round_tc)
        if (vote_msg != None):
            #send vote msg to LeaderElection.get leader(current round+ 1)
            pass

    def process_timeout_msg(M : TimeoutMsg):
        pass

    def process_vote_msg():
        pass

    def process_new_round_event():
        pass

    #Handler for local timeout
    def receive(msg=(LOCAL_TIMEOUT, local_timeout_message), from_ = replica):
        process_timeout_msg(local_timeout_message)
        pass

    #Handler for client message
    def receive(msg=(CLIENT_MESSAGE, client_request_message), from_ = client):
        client_id = client_request_message.id
        client_verify_key = verify_key_list_client[client_id]
        client_msg = verify_and_get_signed_message(client_request_message.signed_message, client_verify_key)
        output("Client", client_id,  "Sent me this message : ", client_msg)
        tot_msg -= 1

#Returns a list of  signing & verify keys of length count
def generate_signing_and_verify_keys(count : int):
    signing_key_list, verify_key_list = [], []
    for _ in range(count):
        sk = SigningKey.generate()
        signing_key_list.append(sk) #Private Key
        verify_key_list.append(sk.verify_key) #Public Key
    return signing_key_list, verify_key_list #Private Key, Public Key lists

#Sign a message str using a signing key
def sign_message(message : str, signing_key : nacl.signing.SigningKey):
    #Encode the message
    message = message.encode('ascii')
    #Sign the message and return the signed message
    return signing_key.sign(message)

#Verifies the signed message and returns the message
def verify_and_get_signed_message(signed_message : str, verify_key : nacl.signing.VerifyKey):
    verify_key.verify(signed_message)
    return signed_message.message.decode('ascii')

def main():
    nclients = int(sys.argv[1]) if len(sys.argv) > 1 else 3
    nreplicas = int(sys.argv[2]) if len(sys.argv) > 2 else 10
    ngst = 3000

    clients = new(Client, num = nclients)
    replicas = new(Replica, num = nreplicas)

    signing_key_list_client, verify_key_list_client = generate_signing_and_verify_keys(nclients)
    signing_key_list_replica, verify_key_list_replica = generate_signing_and_verify_keys(nreplicas)
    
    output("client length " , len(clients))
    output("replica length " , len(replicas))

    #def setup(client_id, replicas, verify_key, signing_key, verify_key_list_replica):
    #Client will have it's own signing key, verify key and, list of verify keys of replicas
    for i, client in enumerate(clients):
        setup(client, (i, replicas, verify_key_list_client[i], signing_key_list_client[i], verify_key_list_replica))

    #def setup(replica_id, replicas, verify_key, signing_key, verify_key_list_replica, verify_key_list_client):
    for i, replica in enumerate(replicas):
        setup(replica, (i, replicas, verify_key_list_replica[i], signing_key_list_replica[i], verify_key_list_replica, verify_key_list_client))
    
    start(replicas)
    start(clients)
